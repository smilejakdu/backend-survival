# Layered Architecture

* 관심사의 분리
  * 커다란 프로그램은 유지보수가 어렵다. 인간의 한계 + 공간의 한계, 유지보수가 가능하도록 적절하게 나누고, 그룹화 해야한다. 파일 시스템의 폴더나 Java의 패키지 등이 이를 위해 존재한다.\
    인간의 한계를 알고 효율적으로 활용하자. !
  * 관심사의 분리에 따라서 코드분리 , 코드를 어떻게 배치하느냐 = 설계, 설계 개선
* 응집도\
  한 클래스나 모듈 내부의 요소들이 서로 얼마나 밀접하게 관련되어 있는지를 나타낸다.\
  응집도가 높을수록 클래스나 모듈은 하나의 명확한 목적이나 기능에 집중한다.
* 결합도\
  서로 다른 클래스나 모듈 간의 의존 관계의 정도를 나타낸다. 결합도가 낮을수록 각 클래스나 모듈은 서로 독립적이며, 변경에 대한 영향이 적어집니다.
  * DI 와 IOC는 객체 간의 결합도를 낮춥니다. 객체는 필요한 의존성을 외부에서 주입받기 때문에 , 특정 구현에 강하게 결합되지 않습니다. 이는 코드의 유연성을 높이고 , 테스트와 유지보수를 용이하게 합니다.
  * DI 와 IOC 를 사용하게 되면 설계가 조금더 깔끔하게 됩니다. \
    각 클래스는 자신의 역할에 집중할 수 있게되고, 외부 의존성에 대해서는 걱정할 필요가 없어지게 됩니다.&#x20;
* Layered Atchitecture
* UUID
  * 소프트웨어  개발에서 고유성을 보장하는데 사용되는 128비트의 숫자이다. 이 식별자는 전 세계적으로 고유하며 , 중복될 확률이 극히 낮다.
  * `String id = UUID.randomUUID().toString();`
* ULID
  * Sortable 한 UUID\
    ![](<../.gitbook/assets/스크린샷 2023-11-19 오전 11.56.20.png>)
  * UUID 의 장점을 유지하면서 몇가지 추가적인 이점을 제공한다.
    * 정렬: ULID 는 시간 기반으로 생성되며 , 이로 인해 생성된 순서대로 정렬할 수 있습니다.&#x20;
    * 고유성: ULID 는 UUID 와 마찬가지로 전 세계적으로 고유한 값을 생성할 수 있다.
    * 128비트 크기: ULID 는 128비트 크기를 가지며, 이는 UUID와 동일하다. 이로 인해 기존의 UUID 시스템과 호환성을 유지할 수 있습니다.
  * `String id = UlidCreator.getUlid().toString();`
